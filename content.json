{"meta":{"title":"Evo li's Blog","subtitle":"java blog","description":"a java programmer's blog","author":"lirui","url":"http://hexo.geting-evolution.top","root":"/"},"pages":[],"posts":[{"title":"剑指Offer学习笔记","slug":"剑指Offer学习笔记","date":"2019-06-24T11:31:30.000Z","updated":"2019-06-24T11:33:06.677Z","comments":true,"path":"2019/06/24/剑指Offer学习笔记/","link":"","permalink":"http://hexo.geting-evolution.top/2019/06/24/剑指Offer学习笔记/","excerpt":"","text":"TCP四次挥手1、客户端主动发起结束报文，发送内容是 FIN = 1,seq=u，状态变更为FIN WAIT-1。2、服务端收到结束报文后，将给客户端发送 ACK = 1,seq=x,ack=u+1 ，状态变更为 CLOSE WAIT。3、客户端收到服务端的确认报文，状态将变更为FIN WAIT-1，等待服务端再次发送报文。4、服务端向客户端再次发送结束报文，FIN =1,ACK=1,seq=w,ack=u+1。然后进入LAST ACT 最后确认状态。5、客户端收到服务端的结束报文，向服务端发送ACK=1,seq=u+1,ack=w+1，服务端关闭连接。6、客户端关闭连接。 客户端 -&gt; FIN = 1,seq = 1000 -&gt; 服务端状态：客户端 FIN WAIT-1 服务端 CLOSE WAIT 服务端 -&gt; ACK = 1,seq = 800,ack=1000+1=1001 -&gt; 客户端状态：客户端 FIN WAIT-2 服务端 CLOSE WAIT 服务端 -&gt; FIN=1,ACK=1,seq = 801,ack=1001 -&gt; 客户端状态：服务端 LAST ACK 客户端 -&gt; ACK=1,seq=1001+1=1002,ack=801+1=802 -&gt; 服务端状态：客户端 TIME-WAIT 服务端 CLOSE 等待2MSL后客户端 CLOSE MysqlMyISAM和innoDB区别MyISAM默认是表级锁，不支持行级锁。InnoDB默认是行级锁，支持表级锁。 MyISAM锁机制 表级锁 读锁为共享锁但只能被读共享 写锁为排他锁 读锁可以通过语句追加for update变更为排他锁。 非聚集索引，数据和索引是分离的，索引保存的是数据文件的指针，辅助索引是独立的。 在增删改少的系统中，性能优于innodb。 适合场景： 频繁执行全表count语句。 对数据进行增删改的频率不高，查询非常频繁。 InnoDB锁机制 意向锁 二段锁 加锁，通过commit释放锁。 行级锁 加共享读锁，并且是排他（写）锁在语句后追加 lock in share mode,做的操作需要commit才会释放锁。 不走索引的时候，整张表就会被锁住。 有且只有一个聚集索引，数据文件和索引绑定在一起。 适合场景： 数据增删改查都相当频繁。 可靠性要求比较高，要求支持事务。 锁的分类 按锁的粒度划分，可分为表级锁，行级锁，页级锁。 按锁级别划分，可分为共享锁，排他锁。 按加锁方式划分，可分为自动锁，显式锁。 按操作划分，可分为DML锁，DDL锁。 按使用方式划分，可分为，乐观锁，悲观锁。 数据库事务的四大特性ACID 原子性 一致性 隔离性 持久性 事务的隔离级别以及各级别下的并发访问问题 更新丢失—mysql所有事务隔离级别在数据库层面上均可避免 脏读—READ-COMMITTED事务隔离级别以上可以避免 不可重复读—REPEASTABLE-READ事务隔离级别以上可避免 幻读—SERIALIZABLE事务隔离级别可避免锁模块之当前读和快照读RC、RR级别下的InnoDB的非阻塞读如何实现 数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段 undo日志 read viewGap锁会用在非唯一索引或者不走索引的当前读中 Java异常体系Error和Exception的区别 Error: 程序无法处理的系统错误，编译器不做检查。 Exception：程序可以处理的异常，捕获后可能恢复。总结：前者是程序无法处理的错误，后者是可以处理的异常。 常见Error以及Exception RuntimeException NullPointerException - 空指针异常 ClassCastException IllegalArgumentExc IndexOutOfBoundsException NumberFormatExcept 非RuntimeException ClassNotFoundException IOException Error NoClassDefFoundError 1、类依赖的class或者jar不存在 2、类文件存在，但是存在不同的域中 3、大小写问题，javac编译的时候是无视大小写的，很有可能编译出来的class文件就与想要的不一样。 StatckOverflowError 深递归导致栈被耗尽而抛出的异常 OutOfMemoryError Java的异常处理机制 抛出异常：创建异常对象，交由运行时系统处理。 捕获异常：寻找合适的异常处理器处理异常，否则终止运行。Java异常的处理原则 具体明确：抛出的异常应该通过异常类名和message准确说明异常的类型和产生异常的原因。 提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题； 延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。 Java异常处理消耗性能的地方 try-catch块影响jvm的优化 异常对象实例需要保存栈快照等信息，开销较大Java 集合框架数据结构考点 数据组合链表的区别 链表的操作，如反转，链表环路检测，双向链表，循环链表相关操作 队列、栈的应用 二叉树的便利方式及其递归和非递归的实现 红黑树的旋转 算法考点 内部排序：如递归排序，交换排序（冒泡，快排），选择排序，插入排序 外部排序：应掌握如何利用有限的内存配合海量外部存储来处理超大的数据集，写不出来也要有相关思路 TreeSet 必须重写equals，hashCode，实现Compareable接口 最终依靠compare方法来判断对象的唯一 底层是TreeMap Map如何有效的减少碰撞 扰动函数：促使元素位置分布均匀，减少碰撞几率 使用final对象，并采用合适的equals（）和hashCode（）方法 HashMap 线程不安全，数组+链表+红黑树 扩容的问题 多线程环境下，调整大小会存在条件竞争，容易造成死锁。 rehshing是一个比较耗时的过程。 创建一个线程安全的HashMap，使用Collections.synchronizedMap() HashTable 线程安全，锁住整个对象，数组+链表 ConccurentHashMap 线程安全，CAS+同步锁，数组+链表+红黑树 java8 ConccurentHashMap 采用 CAS+synchronized使锁更细化，只要hash不冲突就不会出现锁竞争 成员变量：sizeCtl：大小控制标识符，初始化，扩容标示量 不允许null键和null值 CAS的缺点 循环时间长开销很大。 我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。 只能保证一个共享变量的原子操作。 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。 ABA问题。 如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。 ConcurrentHashMap.put方法的逻辑 判断Node[]数组是否初始化，没有则进行初始化操作 通过hash定位数组的索引坐标，是否有Node节点，如果没有则是用CAS进行添加（链表的头结点），添加失败则进入下次循环。 检查到内容正在扩容，就帮助它一块扩容。 如果f != null，则使用synchronized锁住f元素（链表、红黑树的头元素），并进行相应的添加操作 判断链表长度已经到达临界值8，当然8是默认值，大家也可以去做调整，当节点数超过这个值就需要把链表转换为树结构。 ConcurrentHashMap总结：比起Segment，锁拆得更细 首先使用无锁操作CAS插入头结点，失败则循环重试 若头节点已存在，则尝试获取头节点的同步锁，再进行操作 J.U.C知识点梳理并发工具类闭锁 CountDownLatch让主线程等待一组事件发生后继续执行，通俗来讲就是子线程在主线程中有序执行。 栅栏 CyclicBarrier 阻塞当前线程，等待其他线程 等待其他线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才能继续执行 所有线程到达栅栏处，可触发执行另外一个预先设置的线程信号量 Semaphore 控制某个资源可被同事访问的线程个数交换器 Exchanger 两个线程到达同步点后，相互交换数据集合BlockingQueue: 提供可阻塞的入队和出队操作 主要用于生产者-消费者模式，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够给达到将任务的生产和消费进行隔离的目的 ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列 LinkedBlockingQueue: 一个由链表结构组成的有界/无界阻塞队列,默认大小是Integer.max PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列,如果元素为空take()会受阻 DealyQueue: 一个使用优先级队列实现的无界阻塞队列,延时获取元素 SynchronousQueue: 一个不存储元素的阻塞队列，只能放一个元素 LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列，无锁操作，可以存多个，性能比LinkedBlocingQueue性能要高 LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列，可以从尾部获取，解决当多个消费者来获取时的阻塞问题 JAVA的IO机制BIO Block-IO:InputStream和OutputStream,Reader和Writer NIO java 4|+ NonBlock-IO:构建多路复用的、同步非阻塞的IO操作 Channels FileChannel transferTo: 把FileChannel中的数据拷贝到另外一个Channel transferFrom: 把另外一个Channel中的数据拷贝到FileChannel 避免了两次用户态和内核态间的上下文切换，即“零拷贝”，效率较高 DatagramChannel SocketChannel ServerSocketChannel Buffers Selectorsselect、poll、epoll的区别 支持一个进程能打开的最大连接数 类型 区别 select 单个进程能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小是3232,64位机器上FD_SETSIZE位3264），我们可以对其进行修改，然后重新编译内核，但是性能无法保证，需要进一步测试 poll 本质上与select没有区别，但是他没有最大连接数的限制，原因是它基于链表来存储的 epoll 虽然连接数 有上线，但是很大，1g内存的机器上可以打开10万左右的链接 FD剧增后带来的IO效率问题 类型 区别 select 因为每次调用时都会对连接进行线性便利，所以随着FD的 增加会造成便利速度“线性下降”的性能问题 poll 同上 epoll 由于epoll是根据每个fd上的callback函数来实现对策，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll不会有“线性下降”的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题 消息传递方式 类型 区别 select 内核需要将消息传递到用户控件，需要内核的拷贝动作 poll 同上 epoll 通过内核和用户空间共享一块内存来实现，性能较高 AIO Asynchronous IO: 基于事件和回调机制 基于回调：实现CompletionHandler接口，调用时触发回调函数 返回Future：通过isDone()查看是否准备好，通过get()等待返回数据 BIO、NIO、AIO对比 属性\\模型 阻塞BIO 非阻塞NIO 异步AIO blocking 阻塞并同步 非阻塞但同步 非阻塞并异步 线程数(server:client) 1:1 1:N 0:N 复杂度 简单 较复杂 复杂 吞吐量 低 高 高 JAVA的理解 平台无关性：一次编译到处运行 编译时：编译生成字节码，存入.class文件中 javap反汇编器 javap -c 反汇编 运行时： GC：垃圾回收机制，不需要像C++那样手动释放堆内存 语言特性：泛型、反射、拉姆达表达式 面向对象：封装、继承、多态 类库：集合、并发、网络、IO、NIO 异常处理Java虚拟机 Class Loader: 依据特定格式，加载class文件到内存 Runtime Data Area:JVM内存空间结构模型，Stack、Heap、Method Area、PC Register、Native Method Stack Execution Engine：解释器，对命令进行解析 Native Interface：融合不同开发语言的原生库为java所用ClassLoader BootStrapClassLoader: C++编写，加载核心库java.* ExtClassLoader:Java 编写，加载扩展库javax.* AppClassLoader:Java编写，加载程序所在目录 自定义ClassLoader:Java编写，定制化加载 findClass(name) defineClass(byte[] b, int off, int len)ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制 Customer ClassLoader -&gt; App ClassLoader -&gt; Extension ClassLoader -&gt; Bootstrap ClassLoader 为什么？ 避免多份同样字节码的加载类的加载方式 隐式加载：new 显式加载：loadClass, forName等loadClass和forName的区别 类的装载过程 加载：通过ClassLoader加载class文件字节码，生成Class对象 链接 校验：检查加载的class的正确性和安全性 准备：为类变量分配存储空间并设置类变量初始值 解析：JVM将常量池内的符号引用转换为直接引用 初始化：执行类变量赋值和静态代码块 Class.forName得到的class是已经初始化完成的 Classloader.loadClass得到的是class是还没有链接的 区别产生的作用： Classloader常被spring ioc。Java内存模型内存简介逻辑地址-&gt;分段管理机制-&gt;线性地址-&gt;分页管理机制-&gt;物理地址 32位处理器：2^32的可寻址范围 64位处理器：2^64的可寻址范围地址空间的划分 内核空间：主要的操作系统程序和C运行空间，连接计算机硬件，调度程序，联网，虚拟内存的逻辑和c的进程。 用户空间：Java进程运行时使用的内存空间，最大可访问空间0-3GB内存模型-JDK8 线程私有：程序计数器、虚拟机栈、本地方法栈 线程共享：MetaSpace，Java堆程序计数器（Program Counter Register） 当前线程所执行的字节码行号指示器（逻辑） 改变计数器的值来选取下一条需要执行的字节码指令 和线程是一对一的关系即“线程私有” 对Java方式计数，如果是Native方法则计数器值为Undefined 不会发生内存泄漏Java虚拟机栈（Stack） Java方法执行的内存模型 包含多个栈帧：局部变量表、操作栈、动态连接、返回地址 jstack可以分析栈帧的问题局部变量表和操作数栈的区别 局部变量表：包含方法执行过程中的所有变量 操作数栈：入栈、出栈、复制、交换、产生消费变量 递归为什么会引发java.lang.StatckOverflowError异常：递归过深，栈帧数超出虚拟栈深度 虚拟机栈过多会引发java.lang.OutOfMemoryError异常本地方法栈 与虚拟机相似，主要作用于标注了native的方法元空间(MetaSpace)与永久代(PermGen)的区别 存储Class的相关信息 他们都是方法区的实现 jdk8 元空间替代了永久代 元空间使用本地内存，而永久代使用的是jvm的内存 MetaSpace相比PermGen的优势 字符串常量池在java7后被移动到了堆中 字符串常量池存在永久代中，容易出现性能问题和内存溢出 类和方法的信息大小难以确定，给永久代的大小指定带来困难 永久代会为GC带来不必要的复杂性 方便HotSpot与其他JVM如Jrockit的集成 Java堆（Heap） 对象实例的分配区域 GC管理的主要区域常用面试题1、JVM三大性能调优参数-Xms -Xmx -Xss的含义java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar -Xss: 规定了每个线程虚拟机栈（堆栈）的大小 -Xms: 堆的初始值 -Xmx: 堆能达到的最大值Java内存模型中堆和栈的区别-内存分配策略 静态存储：编译时确定每个数据目标在运行时的存储空间需求 栈式存储：数据区需求在编译时未知，运行时模块入口前确定 堆式存储：编译时或运行时模块入口都无法确定，动态分配堆和栈的区别 联系：引用对象，数组时，栈里定义变量保存堆中目标的首地址 管理方式：栈自动释放，堆需要GC 空间大小：栈比堆小 碎片相关：栈产生的碎片远小于堆 分配方式：栈支持静态和动态分配，而堆仅支持动态分配 效率：栈的效率比堆高元空间、堆、线程独占部分间的联系-内存角度 Java垃圾回收机制引用计数算法 判断对象的引用数量来决定对象是否被回收 每个对象实例都有一个引用计数器，被引用则+1，完成引用则 任何引用计数为0的对象实例可以被当做垃圾收集优点：执行效率高，程序执行受影响较小缺点：无法检测出循环引用的情况，导致内存泄漏可达性分析算法判断对象的引用链是否可达来决定对象是否可以被回收（离散数学：图论） 可以作为GC Root的对象 虚拟机栈中引用的对象（栈帧中的本地变量表） 方法区中的常量引用的对象 方法区中的静态属性引用的对象 本地方法栈中JNI（Native）方法的引用对象 活跃线程的引用对象垃圾回收算法标记-清除算法（Mark and Sweep） 标记：从根集合进行扫描，对存活的对象进行标记 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题处理逻辑 分为对象面和空闲面 对象在对象面上创建 存活的对象被从对象面复制到空闲面 将对象面所有对象内存清除优点 解决碎片化问题 顺序分配内存，简单高效 适用于对象存活率低的场景标记-整理算法(Compacting) 标记：从根集合进行扫描，对存活的对象进行标记 清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收优点 避免内存的不连续性 不用设置两块内存互换 适用于存活率高的场景分代收集算法（Generational Collector） 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法 JDK 6-7 年轻代、老年代、永久代 JDK8 年轻代、老年代 年轻代：复制算法 老年代：标记清楚算法，标记整理算法分代GC的分类，两种 Minor GC 发生在年轻代中的垃圾收集动作，复制算法 Full GC 年轻代：尽可能快速的收集那些生命周期短的对象 Eden区：伊甸园，人来的起源,new 的对象首先放在该区 两个Survivor区 from区 to区 默认的达到永久代的年龄是15，可以通过-XX:MaxTenuringThreshold来设置 对象如何晋升到老年代 经历一定Minor次数依然存活的对象 Survivor区中存放不下的对象 新生成的大对象（-XX:+PretenuerSizeThreshold）常用的性能调优参数 -XX:SurvivorRatio: Eden和Survivor的比值，默认8:1 -XX:NewRatio: 老年代和年轻代内存大小的比例 -XX:MaxTenuringThreshold: 对象从年轻代晋升到老年代经过GC次数的最大阈值老年代：存放生命周期较长的对象 标记-清理算法 标记-整理算法 Full GC和Major GC Full GC比Minor GC慢，执行频率低触发Full GC的条件 老年代空间不足 永久代空间不足 JDK7以及以前版本，JDK8后不成立 CMS GC时出现promotion failed（在进行minor gc时survivor放不下啦，对象只能放在老年代，而此时老年代也放不了）, concurrent mode failure（在执行CMS GC时同时又对象要放入老年代中） Minor GC晋升到老年代的平均大小大于老年代的剩余空间 调用System.gc() 使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC","categories":[],"tags":[]},{"title":"","slug":"springcloudgateway-cors-config","date":"2019-06-04T07:17:46.849Z","updated":"2019-06-04T07:17:46.849Z","comments":true,"path":"2019/06/04/springcloudgateway-cors-config/","link":"","permalink":"http://hexo.geting-evolution.top/2019/06/04/springcloudgateway-cors-config/","excerpt":"","text":"spring cloud gateway 采用的是webflux，所以请使用以下方式自定义跨域配置123456789101112131415161718192021222324252627282930package net.youqu.micro.service.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.reactive.CorsWebFilter;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;import org.springframework.web.util.pattern.PathPatternParser;/** * description: * * @author wangpeng * @date 2019/01/02 */@Configurationpublic class CorsConfig &#123; @Bean public CorsWebFilter corsFilter() &#123; CorsConfiguration config = new CorsConfiguration(); config.addAllowedMethod(&quot;*&quot;); config.addAllowedOrigin(&quot;*&quot;); config.addAllowedHeader(&quot;*&quot;); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsWebFilter(source); &#125;&#125;","categories":[],"tags":[]},{"title":"【JAVA】正则表达式","slug":"【JAVA】正则表达式","date":"2019-05-30T03:46:17.000Z","updated":"2019-05-30T03:56:07.050Z","comments":true,"path":"2019/05/30/【JAVA】正则表达式/","link":"","permalink":"http://hexo.geting-evolution.top/2019/05/30/【JAVA】正则表达式/","excerpt":"","text":"常用正则表达式：网址（URL）: [a-zA-z]+://[^\\s]IP地址(IP Address)：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)电子邮件(Email): \\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)QQ号码: [1-9]\\d{4,} HTML标记(包含内容或自闭合): \\/> ```12密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上): ``` (?=^.&#123;8,&#125;$)(?=.*\\d)(?=.*\\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\\n).*$ 日期(年-月-日) ```1234日期(月/日/年) ``` ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\\d&#123;4&#125;|\\d&#123;2&#125;) ``` 时间(小时:分钟, 24小时制) ``` ((1|0?)[0-9]|2[0-3]):([0-5][0-9]) 汉字(字符) ```12中文及全角标点符号(字符) ``` [\\u3000-\\u301e\\ufe10-\\ufe19\\ufe30-\\ufe44\\ufe50-\\ufe6b\\uff01-\\uffee] 中国大陆固定电话号码 ```12中国大陆手机号码 ``` 1\\d&#123;10&#125; 中国大陆邮政编码 ```12中国大陆身份证号(15位或18位) ``` \\d&#123;15&#125;(\\d\\d[0-9xX])? 非负整数(正整数或零) ```12正整数 ``` [0-9]*[1-9][0-9]* 负整数 ```12整数 ``` -?\\d+ 小数 ```12不包含abc的单词 ``` \\b((?!abc)\\w)+\\b 下面我们来看看一些基本的正则表达式的语法： \\：将下个字符标记为一个特殊的字符、一个原义字符、一个向后引用或者一个八进制转义符例如“\\n”就是匹配一个换行符。 ^：匹配开始位置，^(a)这个就匹配开头必须为a。 \\$：匹配结束位置，$(a)这个就匹配结尾必须为a。 *：匹配前面的子表达式零次或者多次，如“xu”这个表达式就能够匹配“x”和“xuu”。 +：匹配前面的子表达式一次或者多次，如“xu+”这个表达式就能够匹配“xuu”和“xu”，但不能够匹配“x”，这个就是和“”的区别。 ?：匹配前面的子表达式零次或者一次，如“xu？”这个表达式就能够匹配“jian(guo)?”就可以匹配“jian”和“jianguo”。 {n}：n是一个非负数，匹配n次，如“guo{2}”，可以匹配“guoo”，不能匹配“guo”。 {n,}：n是一个非负数，匹配至少n次。 {n, m}：m、n都是非负数，最少匹配n次，最多匹配m次。 (pattern)：匹配pattern并获取匹配结果。 (?:pattern)：匹配pattern但不获取匹配结果。 x|y：匹配x或y，如“(xu|jian)guo”匹配“xuguo”或者“jianguo”。 [xyz]：字符集合，匹配所包含的任意字符。如“[abc]”可以匹配“apple”中的“a”。 [^xyz]：匹配未被包含的字符。 [a-z]：字符范围，匹配指定范围内的任意字符。 [^a-z]：匹配指定不在范围内的任意字符。 \\b：匹配一个单词的边界，如“guo\\b”可以匹配“xujianguo”中的“guo”。 \\B：匹配非单词边界，如“jian\\B”可以匹配“xujianguo”中的“jian”。 \\d：匹配一个数字字符，等价于“[0-9]”。 \\D：匹配一个非数字字符。 \\f：匹配一个换页符。 \\n：匹配一个换行符。 \\r：匹配一个回车符。 \\s：匹配任何空白字符 元字符 描述\\ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\\n。“\\n”匹配换行符。序列“\\”匹配“\\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。^ 匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。\\$ 匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。* 匹配前面的子表达式任意次。例如，zo能匹配“z”，也能匹配“zo”以及“zoo”。等价于{0,}。+ 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。{n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。{n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o”。{n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。? 当该字符紧跟在任何一个其他限制符（,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’].点 匹配除“\\n”和”\\r”之外的任何单个字符。要匹配包括“\\n”和”\\r”在内的任何字符，请使用像“[\\s\\S]”的模式。(pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用\\$0…\\$9属性。要匹配圆括号字符，请使用“(”或“)”。(?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。(?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 python的正则表达式没有完全按照正则表达式规范实现，所以一些高级特性建议使用其他语言如java、scala等(?&lt;!patte_n) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 python的正则表达式没有完全按照正则表达式规范实现，所以一些高级特性建议使用其他语言如java、scala等x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。[xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。[a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\\b 匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\\b就是匹配位置的）。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。\\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\\d 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持\\D 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持\\f 匹配一个换页符。等价于\\x0c和\\cL。\\n 匹配一个换行符。等价于\\x0a和\\cJ。\\r 匹配一个回车符。等价于\\x0d和\\cM。\\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\\S 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]。\\t 匹配一个制表符。等价于\\x09和\\cI。\\v 匹配一个垂直制表符。等价于\\x0b和\\cK。\\w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。\\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。\\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。\\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。\\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。\\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。\\nml 如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（&copy;）。\\p{P} 小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。 其他六个属性： L：字母； M：标记符号（一般不会单独出现）； Z：分隔符（比如空格、换行等）； S：符号（比如数学符号、货币符号等）； N：数字（比如阿拉伯数字、罗马数字等）； C：其他字符。 *注：此语法部分语言不支持，例：javascript。\\&lt; 匹配词（word）的开始（\\&lt;）和结束（>）。例如正则表达式\\&lt;the>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。>( ) 将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \\1 到\\9 的符号来引用。| 将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-30T02:27:55.654Z","updated":"2019-05-30T02:27:55.654Z","comments":true,"path":"2019/05/30/hello-world/","link":"","permalink":"http://hexo.geting-evolution.top/2019/05/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2019-05-30T01:21:58.000Z","updated":"2019-05-30T02:27:55.654Z","comments":true,"path":"2019/05/30/test/","link":"","permalink":"http://hexo.geting-evolution.top/2019/05/30/test/","excerpt":"","text":"test hello world123public static void main()&#123;&#125;","categories":[],"tags":[]}]}