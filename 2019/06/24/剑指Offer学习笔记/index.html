<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>剑指Offer学习笔记 | Evo li&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TCP四次挥手1、客户端主动发起结束报文，发送内容是 FIN = 1,seq=u，状态变更为FIN WAIT-1。2、服务端收到结束报文后，将给客户端发送  ACK = 1,seq=x,ack=u+1  ，状态变更为 CLOSE WAIT。3、客户端收到服务端的确认报文，状态将变更为FIN WAIT-1，等待服务端再次发送报文。4、服务端向客户端再次发送结束报文，FIN =1,ACK=1,seq=">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer学习笔记">
<meta property="og:url" content="http://hexo.geting-evolution.top/2019/06/24/剑指Offer学习笔记/index.html">
<meta property="og:site_name" content="Evo li&#39;s Blog">
<meta property="og:description" content="TCP四次挥手1、客户端主动发起结束报文，发送内容是 FIN = 1,seq=u，状态变更为FIN WAIT-1。2、服务端收到结束报文后，将给客户端发送  ACK = 1,seq=x,ack=u+1  ，状态变更为 CLOSE WAIT。3、客户端收到服务端的确认报文，状态将变更为FIN WAIT-1，等待服务端再次发送报文。4、服务端向客户端再次发送结束报文，FIN =1,ACK=1,seq=">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-06-24T11:33:06.677Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指Offer学习笔记">
<meta name="twitter:description" content="TCP四次挥手1、客户端主动发起结束报文，发送内容是 FIN = 1,seq=u，状态变更为FIN WAIT-1。2、服务端收到结束报文后，将给客户端发送  ACK = 1,seq=x,ack=u+1  ，状态变更为 CLOSE WAIT。3、客户端收到服务端的确认报文，状态将变更为FIN WAIT-1，等待服务端再次发送报文。4、服务端向客户端再次发送结束报文，FIN =1,ACK=1,seq=">
  
    <link rel="alternate" href="/atom.xml" title="Evo li&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Evo li&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">java blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hexo.geting-evolution.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-剑指Offer学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/剑指Offer学习笔记/" class="article-date">
  <time datetime="2019-06-24T11:31:30.000Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      剑指Offer学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>四次挥手<br>1、客户端主动发起结束报文，发送内容是 FIN = 1,seq=u，状态变更为FIN WAIT-1。<br>2、服务端收到结束报文后，将给客户端发送  ACK = 1,seq=x,ack=u+1  ，状态变更为 CLOSE WAIT。<br>3、客户端收到服务端的确认报文，状态将变更为FIN WAIT-1，等待服务端再次发送报文。<br>4、服务端向客户端再次发送结束报文，FIN =1,ACK=1,seq=w,ack=u+1。然后进入LAST ACT 最后确认状态。<br>5、客户端收到服务端的结束报文，向服务端发送ACK=1,seq=u+1,ack=w+1，服务端关闭连接。<br>6、客户端关闭连接。  </p>
<p>客户端 -&gt;    FIN = 1,seq = 1000 -&gt; 服务端<br>状态：客户端 FIN WAIT-1   服务端 CLOSE WAIT  </p>
<p>服务端 -&gt; ACK = 1,seq = 800,ack=1000+1=1001  -&gt; 客户端<br>状态：客户端 FIN WAIT-2   服务端 CLOSE WAIT  </p>
<p>服务端 -&gt; FIN=1,ACK=1,seq = 801,ack=1001 -&gt; 客户端<br>状态：服务端 LAST ACK  </p>
<p>客户端 -&gt; ACK=1,seq=1001+1=1002,ack=801+1=802 -&gt; 服务端<br>状态：客户端 TIME-WAIT   服务端 CLOSE  </p>
<p>等待2MSL后客户端 CLOSE  </p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>MyISAM和innoDB区别<br>MyISAM默认是表级锁，不支持行级锁。<br>InnoDB默认是行级锁，支持表级锁。  </p>
<h2 id="MyISAM锁机制"><a href="#MyISAM锁机制" class="headerlink" title="MyISAM锁机制"></a>MyISAM锁机制</h2><ul>
<li>表级锁  </li>
<li>读锁为共享锁但只能被读共享  </li>
<li>写锁为排他锁  </li>
<li>读锁可以通过语句追加for update变更为排他锁。  </li>
<li>非聚集索引，数据和索引是分离的，索引保存的是数据文件的指针，辅助索引是独立的。  </li>
<li>在增删改少的系统中，性能优于innodb。  </li>
<li>适合场景：   <ul>
<li>频繁执行全表count语句。  </li>
<li>对数据进行增删改的频率不高，查询非常频繁。  </li>
</ul>
</li>
</ul>
<h2 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h2><ul>
<li>意向锁  </li>
<li>二段锁 加锁，通过commit释放锁。  </li>
<li>行级锁  </li>
<li>加共享读锁，并且是排他（写）锁在语句后追加 lock in share mode,做的操作需要commit才会释放锁。  </li>
<li>不走索引的时候，整张表就会被锁住。  </li>
<li>有且只有一个聚集索引，数据文件和索引绑定在一起。  </li>
<li>适合场景：  <ul>
<li>数据增删改查都相当频繁。  </li>
<li>可靠性要求比较高，要求支持事务。  <h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2></li>
</ul>
</li>
<li>按锁的粒度划分，可分为表级锁，行级锁，页级锁。  </li>
<li>按锁级别划分，可分为共享锁，排他锁。  </li>
<li>按加锁方式划分，可分为自动锁，显式锁。  </li>
<li>按操作划分，可分为DML锁，DDL锁。  </li>
<li>按使用方式划分，可分为，乐观锁，悲观锁。  </li>
</ul>
<h2 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h2><p>ACID  </p>
<ul>
<li>原子性  </li>
<li>一致性  </li>
<li>隔离性  </li>
<li>持久性  <h2 id="事务的隔离级别以及各级别下的并发访问问题"><a href="#事务的隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务的隔离级别以及各级别下的并发访问问题"></a>事务的隔离级别以及各级别下的并发访问问题</h2></li>
<li>更新丢失—mysql所有事务隔离级别在数据库层面上均可避免</li>
<li>脏读—READ-COMMITTED事务隔离级别以上可以避免</li>
<li>不可重复读—REPEASTABLE-READ事务隔离级别以上可避免</li>
<li>幻读—SERIALIZABLE事务隔离级别可避免<h2 id="锁模块之当前读和快照读"><a href="#锁模块之当前读和快照读" class="headerlink" title="锁模块之当前读和快照读"></a>锁模块之当前读和快照读</h2><h2 id="RC、RR级别下的InnoDB的非阻塞读如何实现"><a href="#RC、RR级别下的InnoDB的非阻塞读如何实现" class="headerlink" title="RC、RR级别下的InnoDB的非阻塞读如何实现"></a>RC、RR级别下的InnoDB的非阻塞读如何实现</h2></li>
<li>数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段</li>
<li>undo日志</li>
<li>read view<h2 id="Gap锁会用在非唯一索引或者不走索引的当前读中"><a href="#Gap锁会用在非唯一索引或者不走索引的当前读中" class="headerlink" title="Gap锁会用在非唯一索引或者不走索引的当前读中"></a>Gap锁会用在非唯一索引或者不走索引的当前读中</h2></li>
</ul>
<h1 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h1><h2 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h2><ul>
<li>Error: 程序无法处理的系统错误，编译器不做检查。</li>
<li>Exception：程序可以处理的异常，捕获后可能恢复。<br>总结：前者是程序无法处理的错误，后者是可以处理的异常。  <h2 id="常见Error以及Exception"><a href="#常见Error以及Exception" class="headerlink" title="常见Error以及Exception"></a>常见Error以及Exception</h2></li>
<li>RuntimeException<ul>
<li>NullPointerException - 空指针异常</li>
<li>ClassCastException</li>
<li>IllegalArgumentExc </li>
<li>IndexOutOfBoundsException</li>
<li>NumberFormatExcept</li>
</ul>
</li>
<li>非RuntimeException<ul>
<li>ClassNotFoundException</li>
<li>IOException</li>
</ul>
</li>
<li>Error<ul>
<li>NoClassDefFoundError</li>
<li>1、类依赖的class或者jar不存在</li>
<li>2、类文件存在，但是存在不同的域中</li>
<li>3、大小写问题，javac编译的时候是无视大小写的，很有可能编译出来的class文件就与想要的不一样。</li>
<li>StatckOverflowError 深递归导致栈被耗尽而抛出的异常</li>
<li>OutOfMemoryError <h2 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h2></li>
</ul>
</li>
<li>抛出异常：创建异常对象，交由运行时系统处理。</li>
<li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行。<h2 id="Java异常的处理原则"><a href="#Java异常的处理原则" class="headerlink" title="Java异常的处理原则"></a>Java异常的处理原则</h2></li>
<li>具体明确：抛出的异常应该通过异常类名和message准确说明异常的类型和产生异常的原因。</li>
<li>提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题；</li>
<li>延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。 <h2 id="Java异常处理消耗性能的地方"><a href="#Java异常处理消耗性能的地方" class="headerlink" title="Java异常处理消耗性能的地方"></a>Java异常处理消耗性能的地方</h2></li>
<li>try-catch块影响jvm的优化</li>
<li>异常对象实例需要保存栈快照等信息，开销较大<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><h2 id="数据结构考点"><a href="#数据结构考点" class="headerlink" title="数据结构考点"></a>数据结构考点</h2></li>
<li>数据组合链表的区别</li>
<li>链表的操作，如反转，链表环路检测，双向链表，循环链表相关操作</li>
<li>队列、栈的应用</li>
<li>二叉树的便利方式及其递归和非递归的实现</li>
<li>红黑树的旋转 </li>
</ul>
<h2 id="算法考点"><a href="#算法考点" class="headerlink" title="算法考点"></a>算法考点</h2><ul>
<li>内部排序：如递归排序，交换排序（冒泡，快排），选择排序，插入排序</li>
<li>外部排序：应掌握如何利用有限的内存配合海量外部存储来处理超大的数据集，写不出来也要有相关思路</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul>
<li>必须重写equals，hashCode，实现Compareable接口</li>
<li>最终依靠compare方法来判断对象的唯一</li>
<li>底层是TreeMap</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="如何有效的减少碰撞"><a href="#如何有效的减少碰撞" class="headerlink" title="如何有效的减少碰撞"></a>如何有效的减少碰撞</h3><ul>
<li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li>
<li>使用final对象，并采用合适的equals（）和hashCode（）方法</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>线程不安全，数组+链表+红黑树</li>
<li>扩容的问题<ul>
<li>多线程环境下，调整大小会存在条件竞争，容易造成死锁。</li>
<li>rehshing是一个比较耗时的过程。</li>
<li>创建一个线程安全的HashMap，使用Collections.synchronizedMap()</li>
</ul>
</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ul>
<li>线程安全，锁住整个对象，数组+链表 </li>
</ul>
<h3 id="ConccurentHashMap"><a href="#ConccurentHashMap" class="headerlink" title="ConccurentHashMap"></a>ConccurentHashMap</h3><ul>
<li>线程安全，CAS+同步锁，数组+链表+红黑树</li>
<li>java8 ConccurentHashMap 采用 CAS+synchronized使锁更细化，只要hash不冲突就不会出现锁竞争</li>
<li>成员变量：sizeCtl：大小控制标识符，初始化，扩容标示量</li>
<li>不允许null键和null值</li>
</ul>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul>
<li>循环时间长开销很大。<ul>
<li>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。  </li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作。<ul>
<li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</li>
</ul>
</li>
<li>ABA问题。<ul>
<li>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？<br>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</li>
</ul>
</li>
</ul>
<h4 id="ConcurrentHashMap-put方法的逻辑"><a href="#ConcurrentHashMap-put方法的逻辑" class="headerlink" title="ConcurrentHashMap.put方法的逻辑"></a>ConcurrentHashMap.put方法的逻辑</h4><ul>
<li>判断Node[]数组是否初始化，没有则进行初始化操作</li>
<li>通过hash定位数组的索引坐标，是否有Node节点，如果没有则是用CAS进行添加（链表的头结点），添加失败则进入下次循环。</li>
<li>检查到内容正在扩容，就帮助它一块扩容。</li>
<li>如果f != null，则使用synchronized锁住f元素（链表、红黑树的头元素），并进行相应的添加操作</li>
<li>判断链表长度已经到达临界值8，当然8是默认值，大家也可以去做调整，当节点数超过这个值就需要把链表转换为树结构。</li>
</ul>
<h4 id="ConcurrentHashMap总结：比起Segment，锁拆得更细"><a href="#ConcurrentHashMap总结：比起Segment，锁拆得更细" class="headerlink" title="ConcurrentHashMap总结：比起Segment，锁拆得更细"></a>ConcurrentHashMap总结：比起Segment，锁拆得更细</h4><ul>
<li>首先使用无锁操作CAS插入头结点，失败则循环重试</li>
<li>若头节点已存在，则尝试获取头节点的同步锁，再进行操作 </li>
</ul>
<h1 id="J-U-C知识点梳理"><a href="#J-U-C知识点梳理" class="headerlink" title="J.U.C知识点梳理"></a>J.U.C知识点梳理</h1><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 CountDownLatch"></a>闭锁 CountDownLatch</h3><p>让主线程等待一组事件发生后继续执行，通俗来讲就是子线程在主线程中有序执行。</p>
<h3 id="栅栏-CyclicBarrier"><a href="#栅栏-CyclicBarrier" class="headerlink" title="栅栏 CyclicBarrier"></a>栅栏 CyclicBarrier</h3><ul>
<li>阻塞当前线程，等待其他线程<ul>
<li>等待其他线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才能继续执行</li>
<li>所有线程到达栅栏处，可触发执行另外一个预先设置的线程<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3></li>
</ul>
</li>
<li>控制某个资源可被同事访问的线程个数<h3 id="交换器-Exchanger"><a href="#交换器-Exchanger" class="headerlink" title="交换器 Exchanger"></a>交换器 Exchanger</h3></li>
<li>两个线程到达同步点后，相互交换数据<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="BlockingQueue-提供可阻塞的入队和出队操作"><a href="#BlockingQueue-提供可阻塞的入队和出队操作" class="headerlink" title="BlockingQueue: 提供可阻塞的入队和出队操作"></a>BlockingQueue: 提供可阻塞的入队和出队操作</h3></li>
<li>主要用于生产者-消费者模式，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够给达到将任务的生产和消费进行隔离的目的</li>
<li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue: 一个由链表结构组成的有界/无界阻塞队列,默认大小是Integer.max</li>
<li>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列,如果元素为空take()会受阻</li>
<li>DealyQueue: 一个使用优先级队列实现的无界阻塞队列,延时获取元素</li>
<li>SynchronousQueue: 一个不存储元素的阻塞队列，只能放一个元素</li>
<li>LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列，无锁操作，可以存多个，性能比LinkedBlocingQueue性能要高</li>
<li>LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列，可以从尾部获取，解决当多个消费者来获取时的阻塞问题</li>
</ul>
<h1 id="JAVA的IO机制"><a href="#JAVA的IO机制" class="headerlink" title="JAVA的IO机制"></a>JAVA的IO机制</h1><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><ul>
<li>Block-IO:InputStream和OutputStream,Reader和Writer <h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3></li>
<li>java 4|+ NonBlock-IO:构建多路复用的、同步非阻塞的IO操作</li>
<li>Channels<ul>
<li>FileChannel</li>
<li>transferTo: 把FileChannel中的数据拷贝到另外一个Channel</li>
<li>transferFrom: 把另外一个Channel中的数据拷贝到FileChannel</li>
<li>避免了两次用户态和内核态间的上下文切换，即“零拷贝”，效率较高</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
</li>
<li>Buffers </li>
<li>Selectors<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a>select、poll、epoll的区别</h3></li>
</ul>
<h4 id="支持一个进程能打开的最大连接数"><a href="#支持一个进程能打开的最大连接数" class="headerlink" title="支持一个进程能打开的最大连接数"></a>支持一个进程能打开的最大连接数</h4><table>
<thead>
<tr>
<th>类型</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>单个进程能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小是32<em>32,64位机器上FD_SETSIZE位32</em>64），我们可以对其进行修改，然后重新编译内核，但是性能无法保证，需要进一步测试</td>
</tr>
<tr>
<td>poll</td>
<td>本质上与select没有区别，但是他没有最大连接数的限制，原因是它基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>虽然连接数 有上线，但是很大，1g内存的机器上可以打开10万左右的链接</td>
</tr>
</tbody>
</table>
<h4 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h4><table>
<thead>
<tr>
<th>类型</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>因为每次调用时都会对连接进行线性便利，所以随着FD的 增加会造成便利速度“线性下降”的性能问题</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>由于epoll是根据每个fd上的callback函数来实现对策，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll不会有“线性下降”的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题</td>
</tr>
</tbody>
</table>
<h4 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h4><table>
<thead>
<tr>
<th>类型</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>内核需要将消息传递到用户控件，需要内核的拷贝动作</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>通过内核和用户空间共享一块内存来实现，性能较高</td>
</tr>
</tbody>
</table>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><ul>
<li>Asynchronous IO: 基于事件和回调机制<ul>
<li>基于回调：实现CompletionHandler接口，调用时触发回调函数</li>
<li>返回Future：通过isDone()查看是否准备好，通过get()等待返回数据</li>
</ul>
</li>
</ul>
<h3 id="BIO、NIO、AIO对比"><a href="#BIO、NIO、AIO对比" class="headerlink" title="BIO、NIO、AIO对比"></a>BIO、NIO、AIO对比</h3><table>
<thead>
<tr>
<th>属性\模型</th>
<th>阻塞BIO</th>
<th>非阻塞NIO</th>
<th>异步AIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>blocking</td>
<td>阻塞并同步</td>
<td>非阻塞但同步</td>
<td>非阻塞并异步</td>
</tr>
<tr>
<td>线程数(server:client)</td>
<td>1:1</td>
<td>1:N</td>
<td>0:N</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单</td>
<td>较复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<h1 id="JAVA的理解"><a href="#JAVA的理解" class="headerlink" title="JAVA的理解"></a>JAVA的理解</h1><ul>
<li>平台无关性：一次编译到处运行<ul>
<li>编译时：编译生成字节码，存入.class文件中</li>
<li>javap反汇编器 javap -c <classes> 反汇编</classes></li>
<li>运行时：</li>
</ul>
</li>
<li>GC：垃圾回收机制，不需要像C++那样手动释放堆内存</li>
<li>语言特性：泛型、反射、拉姆达表达式</li>
<li>面向对象：封装、继承、多态</li>
<li>类库：集合、并发、网络、IO、NIO</li>
<li>异常处理<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2></li>
<li>Class Loader: 依据特定格式，加载class文件到内存</li>
<li>Runtime Data Area:JVM内存空间结构模型，Stack、Heap、Method Area、PC Register、Native Method Stack</li>
<li>Execution Engine：解释器，对命令进行解析</li>
<li>Native Interface：融合不同开发语言的原生库为java所用<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2></li>
<li>BootStrapClassLoader: C++编写，加载核心库java.*</li>
<li>ExtClassLoader:Java 编写，加载扩展库javax.*</li>
<li>AppClassLoader:Java编写，加载程序所在目录</li>
<li>自定义ClassLoader:Java编写，定制化加载 <ul>
<li>findClass(name)</li>
<li>defineClass(byte[] b, int off, int len)<h2 id="ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制"><a href="#ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制" class="headerlink" title="ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制"></a>ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制</h2></li>
</ul>
</li>
<li>Customer ClassLoader -&gt; App ClassLoader -&gt; Extension ClassLoader -&gt; Bootstrap ClassLoader</li>
<li>为什么？<ul>
<li>避免多份同样字节码的加载<h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2></li>
</ul>
</li>
<li>隐式加载：new</li>
<li>显式加载：loadClass, forName等<h2 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h2></li>
<li>类的装载过程<ul>
<li>加载：通过ClassLoader加载class文件字节码，生成Class对象</li>
<li>链接</li>
<li>校验：检查加载的class的正确性和安全性</li>
<li>准备：为类变量分配存储空间并设置类变量初始值</li>
<li>解析：JVM将常量池内的符号引用转换为直接引用</li>
<li>初始化：执行类变量赋值和静态代码块 </li>
</ul>
</li>
<li>Class.forName得到的class是已经初始化完成的</li>
<li>Classloader.loadClass得到的是class是还没有链接的</li>
<li>区别产生的作用： Classloader常被spring ioc。<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h3>逻辑地址-&gt;分段管理机制-&gt;线性地址-&gt;分页管理机制-&gt;物理地址  <ul>
<li>32位处理器：2^32的可寻址范围</li>
<li>64位处理器：2^64的可寻址范围<h3 id="地址空间的划分"><a href="#地址空间的划分" class="headerlink" title="地址空间的划分"></a>地址空间的划分</h3></li>
</ul>
</li>
<li>内核空间：主要的操作系统程序和C运行空间，连接计算机硬件，调度程序，联网，虚拟内存的逻辑和c的进程。</li>
<li>用户空间：Java进程运行时使用的内存空间，最大可访问空间0-3GB<h3 id="内存模型-JDK8"><a href="#内存模型-JDK8" class="headerlink" title="内存模型-JDK8"></a>内存模型-JDK8</h3></li>
<li>线程私有：程序计数器、虚拟机栈、本地方法栈</li>
<li>线程共享：MetaSpace，Java堆<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4></li>
<li>当前线程所执行的字节码行号指示器（逻辑）</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程是一对一的关系即“线程私有”</li>
<li>对Java方式计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏<h4 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h4></li>
<li>Java方法执行的内存模型</li>
<li>包含多个栈帧：局部变量表、操作栈、动态连接、返回地址</li>
<li>jstack可以分析栈帧的问题<h5 id="局部变量表和操作数栈的区别"><a href="#局部变量表和操作数栈的区别" class="headerlink" title="局部变量表和操作数栈的区别"></a>局部变量表和操作数栈的区别</h5></li>
<li>局部变量表：包含方法执行过程中的所有变量</li>
<li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li>
<li>递归为什么会引发java.lang.StatckOverflowError异常：递归过深，栈帧数超出虚拟栈深度</li>
<li>虚拟机栈过多会引发java.lang.OutOfMemoryError异常<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4></li>
<li>与虚拟机相似，主要作用于标注了native的方法<h4 id="元空间-MetaSpace-与永久代-PermGen-的区别"><a href="#元空间-MetaSpace-与永久代-PermGen-的区别" class="headerlink" title="元空间(MetaSpace)与永久代(PermGen)的区别"></a>元空间(MetaSpace)与永久代(PermGen)的区别</h4></li>
<li>存储Class的相关信息</li>
<li>他们都是方法区的实现</li>
<li>jdk8 元空间替代了永久代</li>
<li>元空间使用本地内存，而永久代使用的是jvm的内存 <h4 id="MetaSpace相比PermGen的优势"><a href="#MetaSpace相比PermGen的优势" class="headerlink" title="MetaSpace相比PermGen的优势"></a>MetaSpace相比PermGen的优势</h4></li>
<li>字符串常量池在java7后被移动到了堆中</li>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性</li>
<li>方便HotSpot与其他JVM如Jrockit的集成  <h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4></li>
<li>对象实例的分配区域</li>
<li>GC管理的主要区域<h3 id="常用面试题"><a href="#常用面试题" class="headerlink" title="常用面试题"></a>常用面试题</h3><h4 id="1、JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#1、JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="1、JVM三大性能调优参数-Xms -Xmx -Xss的含义"></a>1、JVM三大性能调优参数-Xms -Xmx -Xss的含义</h4>java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar  </li>
<li>-Xss: 规定了每个线程虚拟机栈（堆栈）的大小</li>
<li>-Xms: 堆的初始值</li>
<li>-Xmx: 堆能达到的最大值<h4 id="Java内存模型中堆和栈的区别-内存分配策略"><a href="#Java内存模型中堆和栈的区别-内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别-内存分配策略"></a>Java内存模型中堆和栈的区别-内存分配策略</h4></li>
<li>静态存储：编译时确定每个数据目标在运行时的存储空间需求</li>
<li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li>
<li>堆式存储：编译时或运行时模块入口都无法确定，动态分配<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4></li>
<li>联系：引用对象，数组时，栈里定义变量保存堆中目标的首地址</li>
<li>管理方式：栈自动释放，堆需要GC</li>
<li>空间大小：栈比堆小</li>
<li>碎片相关：栈产生的碎片远小于堆</li>
<li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li>
<li>效率：栈的效率比堆高<h4 id="元空间、堆、线程独占部分间的联系-内存角度"><a href="#元空间、堆、线程独占部分间的联系-内存角度" class="headerlink" title="元空间、堆、线程独占部分间的联系-内存角度"></a>元空间、堆、线程独占部分间的联系-内存角度</h4></li>
</ul>
<h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><ul>
<li>判断对象的引用数量来决定对象是否被回收</li>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集<br>优点：执行效率高，程序执行受影响较小<br>缺点：无法检测出循环引用的情况，导致内存泄漏<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2>判断对象的引用链是否可达来决定对象是否可以被回收（离散数学：图论）  <h3 id="可以作为GC-Root的对象"><a href="#可以作为GC-Root的对象" class="headerlink" title="可以作为GC Root的对象"></a>可以作为GC Root的对象</h3></li>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>本地方法栈中JNI（Native）方法的引用对象</li>
<li>活跃线程的引用对象<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h3></li>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存<h3 id="复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题"><a href="#复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题" class="headerlink" title="复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题"></a>复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题</h3><h4 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h4></li>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建</li>
<li>存活的对象被从对象面复制到空闲面</li>
<li>将对象面所有对象内存清除<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景<h3 id="标记-整理算法-Compacting"><a href="#标记-整理算法-Compacting" class="headerlink" title="标记-整理算法(Compacting)"></a>标记-整理算法(Compacting)</h3></li>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li>
<li>避免内存的不连续性</li>
<li>不用设置两块内存互换</li>
<li>适用于存活率高的场景<h3 id="分代收集算法（Generational-Collector）"><a href="#分代收集算法（Generational-Collector）" class="headerlink" title="分代收集算法（Generational Collector）"></a>分代收集算法（Generational Collector）</h3></li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>JDK 6-7 年轻代、老年代、永久代</li>
<li>JDK8 年轻代、老年代<ul>
<li>年轻代：复制算法</li>
<li>老年代：标记清楚算法，标记整理算法<h4 id="分代GC的分类，两种"><a href="#分代GC的分类，两种" class="headerlink" title="分代GC的分类，两种"></a>分代GC的分类，两种</h4></li>
</ul>
</li>
<li>Minor GC 发生在年轻代中的垃圾收集动作，复制算法</li>
<li>Full GC <h4 id="年轻代：尽可能快速的收集那些生命周期短的对象"><a href="#年轻代：尽可能快速的收集那些生命周期短的对象" class="headerlink" title="年轻代：尽可能快速的收集那些生命周期短的对象"></a>年轻代：尽可能快速的收集那些生命周期短的对象</h4></li>
<li>Eden区：伊甸园，人来的起源,new 的对象首先放在该区</li>
<li>两个Survivor区<ul>
<li>from区</li>
<li>to区</li>
</ul>
</li>
<li>默认的达到永久代的年龄是15，可以通过-XX:MaxTenuringThreshold来设置 <h4 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h4></li>
<li>经历一定Minor次数依然存活的对象</li>
<li>Survivor区中存放不下的对象 </li>
<li>新生成的大对象（-XX:+PretenuerSizeThreshold）<h4 id="常用的性能调优参数"><a href="#常用的性能调优参数" class="headerlink" title="常用的性能调优参数"></a>常用的性能调优参数</h4></li>
<li>-XX:SurvivorRatio: Eden和Survivor的比值，默认8:1</li>
<li>-XX:NewRatio: 老年代和年轻代内存大小的比例</li>
<li>-XX:MaxTenuringThreshold: 对象从年轻代晋升到老年代经过GC次数的最大阈值<h4 id="老年代：存放生命周期较长的对象"><a href="#老年代：存放生命周期较长的对象" class="headerlink" title="老年代：存放生命周期较长的对象"></a>老年代：存放生命周期较长的对象</h4></li>
<li>标记-清理算法</li>
<li>标记-整理算法</li>
<li>Full GC和Major GC</li>
<li>Full GC比Minor GC慢，执行频率低<h5 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="触发Full GC的条件"></a>触发Full GC的条件</h5></li>
<li>老年代空间不足</li>
<li>永久代空间不足 JDK7以及以前版本，JDK8后不成立</li>
<li>CMS GC时出现promotion failed（在进行minor gc时survivor放不下啦，对象只能放在老年代，而此时老年代也放不了）, concurrent mode failure（在执行CMS GC时同时又对象要放入老年代中）</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hexo.geting-evolution.top/2019/06/24/剑指Offer学习笔记/" data-id="cjxab0zua0004ogpyydceox1i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/06/04/springcloudgateway-cors-config/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/24/剑指Offer学习笔记/">剑指Offer学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/06/04/springcloudgateway-cors-config/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/30/【JAVA】正则表达式/">【JAVA】正则表达式</a>
          </li>
        
          <li>
            <a href="/2019/05/30/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/05/30/test/">test</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lirui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>