<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指Offer学习笔记</title>
      <link href="/2019/06/24/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/06/24/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>四次挥手<br>1、客户端主动发起结束报文，发送内容是 FIN = 1,seq=u，状态变更为FIN WAIT-1。<br>2、服务端收到结束报文后，将给客户端发送  ACK = 1,seq=x,ack=u+1  ，状态变更为 CLOSE WAIT。<br>3、客户端收到服务端的确认报文，状态将变更为FIN WAIT-1，等待服务端再次发送报文。<br>4、服务端向客户端再次发送结束报文，FIN =1,ACK=1,seq=w,ack=u+1。然后进入LAST ACT 最后确认状态。<br>5、客户端收到服务端的结束报文，向服务端发送ACK=1,seq=u+1,ack=w+1，服务端关闭连接。<br>6、客户端关闭连接。  </p><p>客户端 -&gt;    FIN = 1,seq = 1000 -&gt; 服务端<br>状态：客户端 FIN WAIT-1   服务端 CLOSE WAIT  </p><p>服务端 -&gt; ACK = 1,seq = 800,ack=1000+1=1001  -&gt; 客户端<br>状态：客户端 FIN WAIT-2   服务端 CLOSE WAIT  </p><p>服务端 -&gt; FIN=1,ACK=1,seq = 801,ack=1001 -&gt; 客户端<br>状态：服务端 LAST ACK  </p><p>客户端 -&gt; ACK=1,seq=1001+1=1002,ack=801+1=802 -&gt; 服务端<br>状态：客户端 TIME-WAIT   服务端 CLOSE  </p><p>等待2MSL后客户端 CLOSE  </p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>MyISAM和innoDB区别<br>MyISAM默认是表级锁，不支持行级锁。<br>InnoDB默认是行级锁，支持表级锁。  </p><h2 id="MyISAM锁机制"><a href="#MyISAM锁机制" class="headerlink" title="MyISAM锁机制"></a>MyISAM锁机制</h2><ul><li>表级锁  </li><li>读锁为共享锁但只能被读共享  </li><li>写锁为排他锁  </li><li>读锁可以通过语句追加for update变更为排他锁。  </li><li>非聚集索引，数据和索引是分离的，索引保存的是数据文件的指针，辅助索引是独立的。  </li><li>在增删改少的系统中，性能优于innodb。  </li><li>适合场景：   <ul><li>频繁执行全表count语句。  </li><li>对数据进行增删改的频率不高，查询非常频繁。  </li></ul></li></ul><h2 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h2><ul><li>意向锁  </li><li>二段锁 加锁，通过commit释放锁。  </li><li>行级锁  </li><li>加共享读锁，并且是排他（写）锁在语句后追加 lock in share mode,做的操作需要commit才会释放锁。  </li><li>不走索引的时候，整张表就会被锁住。  </li><li>有且只有一个聚集索引，数据文件和索引绑定在一起。  </li><li>适合场景：  <ul><li>数据增删改查都相当频繁。  </li><li>可靠性要求比较高，要求支持事务。  <h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2></li></ul></li><li>按锁的粒度划分，可分为表级锁，行级锁，页级锁。  </li><li>按锁级别划分，可分为共享锁，排他锁。  </li><li>按加锁方式划分，可分为自动锁，显式锁。  </li><li>按操作划分，可分为DML锁，DDL锁。  </li><li>按使用方式划分，可分为，乐观锁，悲观锁。  </li></ul><h2 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h2><p>ACID  </p><ul><li>原子性  </li><li>一致性  </li><li>隔离性  </li><li>持久性  <h2 id="事务的隔离级别以及各级别下的并发访问问题"><a href="#事务的隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务的隔离级别以及各级别下的并发访问问题"></a>事务的隔离级别以及各级别下的并发访问问题</h2></li><li>更新丢失—mysql所有事务隔离级别在数据库层面上均可避免</li><li>脏读—READ-COMMITTED事务隔离级别以上可以避免</li><li>不可重复读—REPEASTABLE-READ事务隔离级别以上可避免</li><li>幻读—SERIALIZABLE事务隔离级别可避免<h2 id="锁模块之当前读和快照读"><a href="#锁模块之当前读和快照读" class="headerlink" title="锁模块之当前读和快照读"></a>锁模块之当前读和快照读</h2><h2 id="RC、RR级别下的InnoDB的非阻塞读如何实现"><a href="#RC、RR级别下的InnoDB的非阻塞读如何实现" class="headerlink" title="RC、RR级别下的InnoDB的非阻塞读如何实现"></a>RC、RR级别下的InnoDB的非阻塞读如何实现</h2></li><li>数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段</li><li>undo日志</li><li>read view<h2 id="Gap锁会用在非唯一索引或者不走索引的当前读中"><a href="#Gap锁会用在非唯一索引或者不走索引的当前读中" class="headerlink" title="Gap锁会用在非唯一索引或者不走索引的当前读中"></a>Gap锁会用在非唯一索引或者不走索引的当前读中</h2></li></ul><h1 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h1><h2 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h2><ul><li>Error: 程序无法处理的系统错误，编译器不做检查。</li><li>Exception：程序可以处理的异常，捕获后可能恢复。<br>总结：前者是程序无法处理的错误，后者是可以处理的异常。  <h2 id="常见Error以及Exception"><a href="#常见Error以及Exception" class="headerlink" title="常见Error以及Exception"></a>常见Error以及Exception</h2></li><li>RuntimeException<ul><li>NullPointerException - 空指针异常</li><li>ClassCastException</li><li>IllegalArgumentExc </li><li>IndexOutOfBoundsException</li><li>NumberFormatExcept</li></ul></li><li>非RuntimeException<ul><li>ClassNotFoundException</li><li>IOException</li></ul></li><li>Error<ul><li>NoClassDefFoundError</li><li>1、类依赖的class或者jar不存在</li><li>2、类文件存在，但是存在不同的域中</li><li>3、大小写问题，javac编译的时候是无视大小写的，很有可能编译出来的class文件就与想要的不一样。</li><li>StatckOverflowError 深递归导致栈被耗尽而抛出的异常</li><li>OutOfMemoryError <h2 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h2></li></ul></li><li>抛出异常：创建异常对象，交由运行时系统处理。</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行。<h2 id="Java异常的处理原则"><a href="#Java异常的处理原则" class="headerlink" title="Java异常的处理原则"></a>Java异常的处理原则</h2></li><li>具体明确：抛出的异常应该通过异常类名和message准确说明异常的类型和产生异常的原因。</li><li>提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题；</li><li>延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常。 <h2 id="Java异常处理消耗性能的地方"><a href="#Java异常处理消耗性能的地方" class="headerlink" title="Java异常处理消耗性能的地方"></a>Java异常处理消耗性能的地方</h2></li><li>try-catch块影响jvm的优化</li><li>异常对象实例需要保存栈快照等信息，开销较大<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><h2 id="数据结构考点"><a href="#数据结构考点" class="headerlink" title="数据结构考点"></a>数据结构考点</h2></li><li>数据组合链表的区别</li><li>链表的操作，如反转，链表环路检测，双向链表，循环链表相关操作</li><li>队列、栈的应用</li><li>二叉树的便利方式及其递归和非递归的实现</li><li>红黑树的旋转 </li></ul><h2 id="算法考点"><a href="#算法考点" class="headerlink" title="算法考点"></a>算法考点</h2><ul><li>内部排序：如递归排序，交换排序（冒泡，快排），选择排序，插入排序</li><li>外部排序：应掌握如何利用有限的内存配合海量外部存储来处理超大的数据集，写不出来也要有相关思路</li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li>必须重写equals，hashCode，实现Compareable接口</li><li>最终依靠compare方法来判断对象的唯一</li><li>底层是TreeMap</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="如何有效的减少碰撞"><a href="#如何有效的减少碰撞" class="headerlink" title="如何有效的减少碰撞"></a>如何有效的减少碰撞</h3><ul><li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li><li>使用final对象，并采用合适的equals（）和hashCode（）方法</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>线程不安全，数组+链表+红黑树</li><li>扩容的问题<ul><li>多线程环境下，调整大小会存在条件竞争，容易造成死锁。</li><li>rehshing是一个比较耗时的过程。</li><li>创建一个线程安全的HashMap，使用Collections.synchronizedMap()</li></ul></li></ul><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ul><li>线程安全，锁住整个对象，数组+链表 </li></ul><h3 id="ConccurentHashMap"><a href="#ConccurentHashMap" class="headerlink" title="ConccurentHashMap"></a>ConccurentHashMap</h3><ul><li>线程安全，CAS+同步锁，数组+链表+红黑树</li><li>java8 ConccurentHashMap 采用 CAS+synchronized使锁更细化，只要hash不冲突就不会出现锁竞争</li><li>成员变量：sizeCtl：大小控制标识符，初始化，扩容标示量</li><li>不允许null键和null值</li></ul><h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul><li>循环时间长开销很大。<ul><li>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。  </li></ul></li><li>只能保证一个共享变量的原子操作。<ul><li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</li></ul></li><li>ABA问题。<ul><li>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？<br>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</li></ul></li></ul><h4 id="ConcurrentHashMap-put方法的逻辑"><a href="#ConcurrentHashMap-put方法的逻辑" class="headerlink" title="ConcurrentHashMap.put方法的逻辑"></a>ConcurrentHashMap.put方法的逻辑</h4><ul><li>判断Node[]数组是否初始化，没有则进行初始化操作</li><li>通过hash定位数组的索引坐标，是否有Node节点，如果没有则是用CAS进行添加（链表的头结点），添加失败则进入下次循环。</li><li>检查到内容正在扩容，就帮助它一块扩容。</li><li>如果f != null，则使用synchronized锁住f元素（链表、红黑树的头元素），并进行相应的添加操作</li><li>判断链表长度已经到达临界值8，当然8是默认值，大家也可以去做调整，当节点数超过这个值就需要把链表转换为树结构。</li></ul><h4 id="ConcurrentHashMap总结：比起Segment，锁拆得更细"><a href="#ConcurrentHashMap总结：比起Segment，锁拆得更细" class="headerlink" title="ConcurrentHashMap总结：比起Segment，锁拆得更细"></a>ConcurrentHashMap总结：比起Segment，锁拆得更细</h4><ul><li>首先使用无锁操作CAS插入头结点，失败则循环重试</li><li>若头节点已存在，则尝试获取头节点的同步锁，再进行操作 </li></ul><h1 id="J-U-C知识点梳理"><a href="#J-U-C知识点梳理" class="headerlink" title="J.U.C知识点梳理"></a>J.U.C知识点梳理</h1><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 CountDownLatch"></a>闭锁 CountDownLatch</h3><p>让主线程等待一组事件发生后继续执行，通俗来讲就是子线程在主线程中有序执行。</p><h3 id="栅栏-CyclicBarrier"><a href="#栅栏-CyclicBarrier" class="headerlink" title="栅栏 CyclicBarrier"></a>栅栏 CyclicBarrier</h3><ul><li>阻塞当前线程，等待其他线程<ul><li>等待其他线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才能继续执行</li><li>所有线程到达栅栏处，可触发执行另外一个预先设置的线程<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3></li></ul></li><li>控制某个资源可被同事访问的线程个数<h3 id="交换器-Exchanger"><a href="#交换器-Exchanger" class="headerlink" title="交换器 Exchanger"></a>交换器 Exchanger</h3></li><li>两个线程到达同步点后，相互交换数据<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="BlockingQueue-提供可阻塞的入队和出队操作"><a href="#BlockingQueue-提供可阻塞的入队和出队操作" class="headerlink" title="BlockingQueue: 提供可阻塞的入队和出队操作"></a>BlockingQueue: 提供可阻塞的入队和出队操作</h3></li><li>主要用于生产者-消费者模式，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够给达到将任务的生产和消费进行隔离的目的</li><li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue: 一个由链表结构组成的有界/无界阻塞队列,默认大小是Integer.max</li><li>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列,如果元素为空take()会受阻</li><li>DealyQueue: 一个使用优先级队列实现的无界阻塞队列,延时获取元素</li><li>SynchronousQueue: 一个不存储元素的阻塞队列，只能放一个元素</li><li>LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列，无锁操作，可以存多个，性能比LinkedBlocingQueue性能要高</li><li>LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列，可以从尾部获取，解决当多个消费者来获取时的阻塞问题</li></ul><h1 id="JAVA的IO机制"><a href="#JAVA的IO机制" class="headerlink" title="JAVA的IO机制"></a>JAVA的IO机制</h1><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><ul><li>Block-IO:InputStream和OutputStream,Reader和Writer <h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3></li><li>java 4|+ NonBlock-IO:构建多路复用的、同步非阻塞的IO操作</li><li>Channels<ul><li>FileChannel</li><li>transferTo: 把FileChannel中的数据拷贝到另外一个Channel</li><li>transferFrom: 把另外一个Channel中的数据拷贝到FileChannel</li><li>避免了两次用户态和内核态间的上下文切换，即“零拷贝”，效率较高</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul></li><li>Buffers </li><li>Selectors<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a>select、poll、epoll的区别</h3></li></ul><h4 id="支持一个进程能打开的最大连接数"><a href="#支持一个进程能打开的最大连接数" class="headerlink" title="支持一个进程能打开的最大连接数"></a>支持一个进程能打开的最大连接数</h4><table><thead><tr><th>类型</th><th>区别</th></tr></thead><tbody><tr><td>select</td><td>单个进程能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小是32<em>32,64位机器上FD_SETSIZE位32</em>64），我们可以对其进行修改，然后重新编译内核，但是性能无法保证，需要进一步测试</td></tr><tr><td>poll</td><td>本质上与select没有区别，但是他没有最大连接数的限制，原因是它基于链表来存储的</td></tr><tr><td>epoll</td><td>虽然连接数 有上线，但是很大，1g内存的机器上可以打开10万左右的链接</td></tr></tbody></table><h4 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h4><table><thead><tr><th>类型</th><th>区别</th></tr></thead><tbody><tr><td>select</td><td>因为每次调用时都会对连接进行线性便利，所以随着FD的 增加会造成便利速度“线性下降”的性能问题</td></tr><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>由于epoll是根据每个fd上的callback函数来实现对策，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll不会有“线性下降”的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题</td></tr></tbody></table><h4 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h4><table><thead><tr><th>类型</th><th>区别</th></tr></thead><tbody><tr><td>select</td><td>内核需要将消息传递到用户控件，需要内核的拷贝动作</td></tr><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>通过内核和用户空间共享一块内存来实现，性能较高</td></tr></tbody></table><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><ul><li>Asynchronous IO: 基于事件和回调机制<ul><li>基于回调：实现CompletionHandler接口，调用时触发回调函数</li><li>返回Future：通过isDone()查看是否准备好，通过get()等待返回数据</li></ul></li></ul><h3 id="BIO、NIO、AIO对比"><a href="#BIO、NIO、AIO对比" class="headerlink" title="BIO、NIO、AIO对比"></a>BIO、NIO、AIO对比</h3><table><thead><tr><th>属性\模型</th><th>阻塞BIO</th><th>非阻塞NIO</th><th>异步AIO</th></tr></thead><tbody><tr><td>blocking</td><td>阻塞并同步</td><td>非阻塞但同步</td><td>非阻塞并异步</td></tr><tr><td>线程数(server:client)</td><td>1:1</td><td>1:N</td><td>0:N</td></tr><tr><td>复杂度</td><td>简单</td><td>较复杂</td><td>复杂</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><h1 id="JAVA的理解"><a href="#JAVA的理解" class="headerlink" title="JAVA的理解"></a>JAVA的理解</h1><ul><li>平台无关性：一次编译到处运行<ul><li>编译时：编译生成字节码，存入.class文件中</li><li>javap反汇编器 javap -c <classes> 反汇编</classes></li><li>运行时：</li></ul></li><li>GC：垃圾回收机制，不需要像C++那样手动释放堆内存</li><li>语言特性：泛型、反射、拉姆达表达式</li><li>面向对象：封装、继承、多态</li><li>类库：集合、并发、网络、IO、NIO</li><li>异常处理<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2></li><li>Class Loader: 依据特定格式，加载class文件到内存</li><li>Runtime Data Area:JVM内存空间结构模型，Stack、Heap、Method Area、PC Register、Native Method Stack</li><li>Execution Engine：解释器，对命令进行解析</li><li>Native Interface：融合不同开发语言的原生库为java所用<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2></li><li>BootStrapClassLoader: C++编写，加载核心库java.*</li><li>ExtClassLoader:Java 编写，加载扩展库javax.*</li><li>AppClassLoader:Java编写，加载程序所在目录</li><li>自定义ClassLoader:Java编写，定制化加载 <ul><li>findClass(name)</li><li>defineClass(byte[] b, int off, int len)<h2 id="ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制"><a href="#ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制" class="headerlink" title="ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制"></a>ClassLoader的双亲委派机制，不同类加载器加载路径不同，各司其职，为了使这些类能相互协作则有了该机制</h2></li></ul></li><li>Customer ClassLoader -&gt; App ClassLoader -&gt; Extension ClassLoader -&gt; Bootstrap ClassLoader</li><li>为什么？<ul><li>避免多份同样字节码的加载<h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2></li></ul></li><li>隐式加载：new</li><li>显式加载：loadClass, forName等<h2 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h2></li><li>类的装载过程<ul><li>加载：通过ClassLoader加载class文件字节码，生成Class对象</li><li>链接</li><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li><li>初始化：执行类变量赋值和静态代码块 </li></ul></li><li>Class.forName得到的class是已经初始化完成的</li><li>Classloader.loadClass得到的是class是还没有链接的</li><li>区别产生的作用： Classloader常被spring ioc。<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h3>逻辑地址-&gt;分段管理机制-&gt;线性地址-&gt;分页管理机制-&gt;物理地址  <ul><li>32位处理器：2^32的可寻址范围</li><li>64位处理器：2^64的可寻址范围<h3 id="地址空间的划分"><a href="#地址空间的划分" class="headerlink" title="地址空间的划分"></a>地址空间的划分</h3></li></ul></li><li>内核空间：主要的操作系统程序和C运行空间，连接计算机硬件，调度程序，联网，虚拟内存的逻辑和c的进程。</li><li>用户空间：Java进程运行时使用的内存空间，最大可访问空间0-3GB<h3 id="内存模型-JDK8"><a href="#内存模型-JDK8" class="headerlink" title="内存模型-JDK8"></a>内存模型-JDK8</h3></li><li>线程私有：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享：MetaSpace，Java堆<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4></li><li>当前线程所执行的字节码行号指示器（逻辑）</li><li>改变计数器的值来选取下一条需要执行的字节码指令</li><li>和线程是一对一的关系即“线程私有”</li><li>对Java方式计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏<h4 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h4></li><li>Java方法执行的内存模型</li><li>包含多个栈帧：局部变量表、操作栈、动态连接、返回地址</li><li>jstack可以分析栈帧的问题<h5 id="局部变量表和操作数栈的区别"><a href="#局部变量表和操作数栈的区别" class="headerlink" title="局部变量表和操作数栈的区别"></a>局部变量表和操作数栈的区别</h5></li><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈、出栈、复制、交换、产生消费变量</li><li>递归为什么会引发java.lang.StatckOverflowError异常：递归过深，栈帧数超出虚拟栈深度</li><li>虚拟机栈过多会引发java.lang.OutOfMemoryError异常<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4></li><li>与虚拟机相似，主要作用于标注了native的方法<h4 id="元空间-MetaSpace-与永久代-PermGen-的区别"><a href="#元空间-MetaSpace-与永久代-PermGen-的区别" class="headerlink" title="元空间(MetaSpace)与永久代(PermGen)的区别"></a>元空间(MetaSpace)与永久代(PermGen)的区别</h4></li><li>存储Class的相关信息</li><li>他们都是方法区的实现</li><li>jdk8 元空间替代了永久代</li><li>元空间使用本地内存，而永久代使用的是jvm的内存 <h4 id="MetaSpace相比PermGen的优势"><a href="#MetaSpace相比PermGen的优势" class="headerlink" title="MetaSpace相比PermGen的优势"></a>MetaSpace相比PermGen的优势</h4></li><li>字符串常量池在java7后被移动到了堆中</li><li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会为GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如Jrockit的集成  <h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4></li><li>对象实例的分配区域</li><li>GC管理的主要区域<h3 id="常用面试题"><a href="#常用面试题" class="headerlink" title="常用面试题"></a>常用面试题</h3><h4 id="1、JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#1、JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="1、JVM三大性能调优参数-Xms -Xmx -Xss的含义"></a>1、JVM三大性能调优参数-Xms -Xmx -Xss的含义</h4>java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar  </li><li>-Xss: 规定了每个线程虚拟机栈（堆栈）的大小</li><li>-Xms: 堆的初始值</li><li>-Xmx: 堆能达到的最大值<h4 id="Java内存模型中堆和栈的区别-内存分配策略"><a href="#Java内存模型中堆和栈的区别-内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别-内存分配策略"></a>Java内存模型中堆和栈的区别-内存分配策略</h4></li><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求</li><li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4></li><li>联系：引用对象，数组时，栈里定义变量保存堆中目标的首地址</li><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比堆小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高<h4 id="元空间、堆、线程独占部分间的联系-内存角度"><a href="#元空间、堆、线程独占部分间的联系-内存角度" class="headerlink" title="元空间、堆、线程独占部分间的联系-内存角度"></a>元空间、堆、线程独占部分间的联系-内存角度</h4></li></ul><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><ul><li>判断对象的引用数量来决定对象是否被回收</li><li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则</li><li>任何引用计数为0的对象实例可以被当做垃圾收集<br>优点：执行效率高，程序执行受影响较小<br>缺点：无法检测出循环引用的情况，导致内存泄漏<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2>判断对象的引用链是否可达来决定对象是否可以被回收（离散数学：图论）  <h3 id="可以作为GC-Root的对象"><a href="#可以作为GC-Root的对象" class="headerlink" title="可以作为GC Root的对象"></a>可以作为GC Root的对象</h3></li><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法区中的常量引用的对象</li><li>方法区中的静态属性引用的对象</li><li>本地方法栈中JNI（Native）方法的引用对象</li><li>活跃线程的引用对象<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h3></li><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存<h3 id="复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题"><a href="#复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题" class="headerlink" title="复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题"></a>复制算法，适用对象存活率低的场景，空间换时间，解决碎片化的问题</h3><h4 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h4></li><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>存活的对象被从对象面复制到空闲面</li><li>将对象面所有对象内存清除<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景<h3 id="标记-整理算法-Compacting"><a href="#标记-整理算法-Compacting" class="headerlink" title="标记-整理算法(Compacting)"></a>标记-整理算法(Compacting)</h3></li><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li><li>避免内存的不连续性</li><li>不用设置两块内存互换</li><li>适用于存活率高的场景<h3 id="分代收集算法（Generational-Collector）"><a href="#分代收集算法（Generational-Collector）" class="headerlink" title="分代收集算法（Generational Collector）"></a>分代收集算法（Generational Collector）</h3></li><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li><li>JDK 6-7 年轻代、老年代、永久代</li><li>JDK8 年轻代、老年代<ul><li>年轻代：复制算法</li><li>老年代：标记清楚算法，标记整理算法<h4 id="分代GC的分类，两种"><a href="#分代GC的分类，两种" class="headerlink" title="分代GC的分类，两种"></a>分代GC的分类，两种</h4></li></ul></li><li>Minor GC 发生在年轻代中的垃圾收集动作，复制算法</li><li>Full GC <h4 id="年轻代：尽可能快速的收集那些生命周期短的对象"><a href="#年轻代：尽可能快速的收集那些生命周期短的对象" class="headerlink" title="年轻代：尽可能快速的收集那些生命周期短的对象"></a>年轻代：尽可能快速的收集那些生命周期短的对象</h4></li><li>Eden区：伊甸园，人来的起源,new 的对象首先放在该区</li><li>两个Survivor区<ul><li>from区</li><li>to区</li></ul></li><li>默认的达到永久代的年龄是15，可以通过-XX:MaxTenuringThreshold来设置 <h4 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h4></li><li>经历一定Minor次数依然存活的对象</li><li>Survivor区中存放不下的对象 </li><li>新生成的大对象（-XX:+PretenuerSizeThreshold）<h4 id="常用的性能调优参数"><a href="#常用的性能调优参数" class="headerlink" title="常用的性能调优参数"></a>常用的性能调优参数</h4></li><li>-XX:SurvivorRatio: Eden和Survivor的比值，默认8:1</li><li>-XX:NewRatio: 老年代和年轻代内存大小的比例</li><li>-XX:MaxTenuringThreshold: 对象从年轻代晋升到老年代经过GC次数的最大阈值<h4 id="老年代：存放生命周期较长的对象"><a href="#老年代：存放生命周期较长的对象" class="headerlink" title="老年代：存放生命周期较长的对象"></a>老年代：存放生命周期较长的对象</h4></li><li>标记-清理算法</li><li>标记-整理算法</li><li>Full GC和Major GC</li><li>Full GC比Minor GC慢，执行频率低<h5 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="触发Full GC的条件"></a>触发Full GC的条件</h5></li><li>老年代空间不足</li><li>永久代空间不足 JDK7以及以前版本，JDK8后不成立</li><li>CMS GC时出现promotion failed（在进行minor gc时survivor放不下啦，对象只能放在老年代，而此时老年代也放不了）, concurrent mode failure（在执行CMS GC时同时又对象要放入老年代中）</li><li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li><li>调用System.gc()</li><li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/04/springcloudgateway-cors-config/"/>
      <url>/2019/06/04/springcloudgateway-cors-config/</url>
      
        <content type="html"><![CDATA[<p>spring cloud gateway 采用的是webflux，所以请使用以下方式自定义跨域配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package net.youqu.micro.service.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.reactive.CorsWebFilter;</span><br><span class="line">import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;</span><br><span class="line">import org.springframework.web.util.pattern.PathPatternParser;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * description:</span><br><span class="line"> *</span><br><span class="line"> * @author wangpeng</span><br><span class="line"> * @date 2019/01/02</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsWebFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config = new CorsConfiguration();</span><br><span class="line">        config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">        config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【JAVA】正则表达式</title>
      <link href="/2019/05/30/%E3%80%90JAVA%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/05/30/%E3%80%90JAVA%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="常用正则表达式："><a href="#常用正则表达式：" class="headerlink" title="常用正则表达式："></a>常用正则表达式：</h3><p>网址（URL）:  [a-zA-z]+://[^\s]<em><br>IP地址(IP Address)：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)<br>电子邮件(Email): \w+([-+.]\w+)</em>@\w+([-.]\w+)<em>.\w+([-.]\w+)</em><br>QQ号码:    [1-9]\d{4,}</p><p>HTML标记(包含内容或自闭合):    <figure class="highlight plain"><figcaption><span>\/> ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上):``` (?=^.&#123;8,&#125;$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$</span><br></pre></td></tr></table></figure></p><p>日期(年-月-日)    <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">日期(月/日/年) ``` ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d&#123;4&#125;|\d&#123;2&#125;) ``` </span><br><span class="line"></span><br><span class="line">时间(小时:分钟, 24小时制)``` ((1|0?)[0-9]|2[0-3]):([0-5][0-9])</span><br></pre></td></tr></table></figure></p><p>汉字(字符)    <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">中文及全角标点符号(字符) ``` [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]</span><br></pre></td></tr></table></figure></p><p>中国大陆固定电话号码    <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">中国大陆手机号码``` 1\d&#123;10&#125;</span><br></pre></td></tr></table></figure></p><p>中国大陆邮政编码    <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">中国大陆身份证号(15位或18位) ``` \d&#123;15&#125;(\d\d[0-9xX])?</span><br></pre></td></tr></table></figure></p><p>非负整数(正整数或零)    <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">正整数 ``` [0-9]*[1-9][0-9]*</span><br></pre></td></tr></table></figure></p><p>负整数 <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">整数  ```-?\d+</span><br></pre></td></tr></table></figure></p><p>小数 <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不包含abc的单词``` \b((?!abc)\w)+\b</span><br></pre></td></tr></table></figure></p><p>下面我们来看看一些基本的正则表达式的语法：<br>　　\：将下个字符标记为一个特殊的字符、一个原义字符、一个向后引用或者一个八进制转义符例如“\n”就是匹配一个换行符。<br>　　^：匹配开始位置，^(a)这个就匹配开头必须为a。<br>　　\$：匹配结束位置，$(a)这个就匹配结尾必须为a。<br>　　*：匹配前面的子表达式零次或者多次，如“xu<em>”这个表达式就能够匹配“x”和“xuu”。<br>　　+：匹配前面的子表达式一次或者多次，如“xu+”这个表达式就能够匹配“xuu”和“xu”，但不能够匹配“x”，这个就是和“</em>”的区别。<br>　　?：匹配前面的子表达式零次或者一次，如“xu？”这个表达式就能够匹配“jian(guo)?”就可以匹配“jian”和“jianguo”。<br>　　{n}：n是一个非负数，匹配n次，如“guo{2}”，可以匹配“guoo”，不能匹配“guo”。<br>　　{n,}：n是一个非负数，匹配至少n次。<br>　　{n, m}：m、n都是非负数，最少匹配n次，最多匹配m次。<br>　　(pattern)：匹配pattern并获取匹配结果。<br>　　(?:pattern)：匹配pattern但不获取匹配结果。<br>　　x|y：匹配x或y，如“(xu|jian)guo”匹配“xuguo”或者“jianguo”。<br>　　[xyz]：字符集合，匹配所包含的任意字符。如“[abc]”可以匹配“apple”中的“a”。<br>　　[^xyz]：匹配未被包含的字符。<br>　　[a-z]：字符范围，匹配指定范围内的任意字符。<br>　　[^a-z]：匹配指定不在范围内的任意字符。<br>　　\b：匹配一个单词的边界，如“guo\b”可以匹配“xujianguo”中的“guo”。<br>　　\B：匹配非单词边界，如“jian\B”可以匹配“xujianguo”中的“jian”。<br>　　\d：匹配一个数字字符，等价于“[0-9]”。<br>　　\D：匹配一个非数字字符。<br>　　\f：匹配一个换页符。<br>　　\n：匹配一个换行符。<br>　　\r：匹配一个回车符。<br>　　\s：匹配任何空白字符    </p><p>元字符    描述<br>\    将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。<br>^    匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。<br>\$    匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。<br>*    匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于{0,}。<br>+    匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。<br>?    匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。<br>{n}    n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。<br>{n,}    n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o<em>”。<br>{n,m}    m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。<br>?    当该字符紧跟在任何一个其他限制符（</em>,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]<br>.点    匹配除“\n”和”\r”之外的任何单个字符。要匹配包括“\n”和”\r”在内的任何字符，请使用像“[\s\S]”的模式。<br>(pattern)    匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用\$0…\$9属性。要匹配圆括号字符，请使用“(”或“)”。<br>(?:pattern)    非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。<br>(?=pattern)    非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern)    非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。<br>(?&lt;=pattern)    非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。<br>    <em>python的正则表达式没有完全按照正则表达式规范实现，所以一些高级特性建议使用其他语言如java、scala等<br>(?&lt;!patte_n)    非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。    </em>python的正则表达式没有完全按照正则表达式规范实现，所以一些高级特性建议使用其他语言如java、scala等<br>x|y    匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。<br>[xyz]    字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。<br>[^xyz]    负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。<br>[a-z]    字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。<br>    注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.<br>[^a-z]    负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。<br>\b    匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。<br>\B    匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。<br>\cx    匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。<br>\d    匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持<br>\D    匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持<br>\f    匹配一个换页符。等价于\x0c和\cL。<br>\n    匹配一个换行符。等价于\x0a和\cJ。<br>\r    匹配一个回车符。等价于\x0d和\cM。<br>\s    匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。<br>\S    匹配任何可见字符。等价于[^ \f\n\r\t\v]。<br>\t    匹配一个制表符。等价于\x09和\cI。<br>\v    匹配一个垂直制表符。等价于\x0b和\cK。<br>\w    匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。<br>\W    匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。<br>\xn    匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。<br>\num    匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。<br>\n    标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。<br>\nm    标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。<br>\nml    如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。<br>\un    匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。<br>\p{P}    小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。<br>    其他六个属性：<br>    L：字母；<br>    M：标记符号（一般不会单独出现）；<br>    Z：分隔符（比如空格、换行等）；<br>    S：符号（比如数学符号、货币符号等）；<br>    N：数字（比如阿拉伯数字、罗马数字等）；<br>    C：其他字符。<br>    *注：此语法部分语言不支持，例：javascript。<br>\&lt;    匹配词（word）的开始（\&lt;）和结束（>）。例如正则表达式\&lt;the>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。<br>><br>( )    将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。<br>|    将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/30/hello-world/"/>
      <url>/2019/05/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/05/30/test/"/>
      <url>/2019/05/30/test/</url>
      
        <content type="html"><![CDATA[<p>test hello world<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
